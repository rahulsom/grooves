<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Grooves</title>
<link rel="stylesheet" href="./grooves.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>
</head>

<body class="article toc2 toc-left">
<div id="header">
<h1>Grooves</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a>
<ul class="sectlevel2">
<li><a href="#_event_sourcing_concepts">Event Sourcing Concepts</a></li>
<li><a href="#_cqrs">CQRS</a></li>
<li><a href="#_representing_events">Representing Events</a></li>
</ul>
</li>
<li><a href="#_hurdles">Hurdles</a>
<ul class="sectlevel2">
<li><a href="#_completeness_of_queries">Completeness of Queries</a></li>
<li><a href="#_reverting_events">Reverting Events</a></li>
<li><a href="#_merging_aggregates">Merging Aggregates</a></li>
<li><a href="#_reverting_merges">Reverting Merges</a></li>
<li><a href="#_performing_joins">Performing joins</a></li>
<li><a href="#_performing_disjoins">Performing disjoins</a></li>
</ul>
</li>
<li><a href="#_how_grooves_solves_it">How Grooves solves it</a></li>
<li><a href="#_event_sourcing_with_grooves">Event Sourcing with Grooves</a>
<ul class="sectlevel2">
<li><a href="#_dependencies">Dependencies</a></li>
<li><a href="#_aggregates">Aggregates</a></li>
<li><a href="#_events">Events</a></li>
<li><a href="#_snapshots">Snapshots</a></li>
<li><a href="#_queries">Queries</a></li>
<li><a href="#_joins">Joins</a></li>
<li><a href="#_frp_style">FRP Style</a></li>
</ul>
</li>
<li><a href="#_creating_your_own_diagrams">Creating your own diagrams</a></li>
<li><a href="#_support">Support</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Formerly, <em>Groovy + Event Sourcing</em>.
Now, <em>Grooves</em> is just a name.
It supports Event Sourcing on many JVM languages.
Examples and tests are included in java, kotlin, and of course, groovy.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Event Sourcing is a way of storing data for flexible retrieval.
The principle behind Event Sourcing is very simple.
We treat our database like a log file.
It is a record of everything that happened as events, and we read these events in order to compute the state of things like we do while debugging an application from the logs.</p>
</div>
<div class="sect2">
<h3 id="_event_sourcing_concepts">Event Sourcing Concepts</h3>
<div class="paragraph">
<p>Here are some things that we will need to get familiar with, that are relevant to Event Sourcing.</p>
</div>
<div class="sect3">
<h4 id="_aggregate">Aggregate</h4>
<div class="paragraph">
<p>An aggregate is a type of object that you are interested in managing data about.
A classic example would be a bank account.</p>
</div>
</div>
<div class="sect3">
<h4 id="_event">Event</h4>
<div class="paragraph">
<p>An event is an atomic change that needs to occur on the aggregate.
A suitable example for the bank account would be a transaction.
It could be an ATM withdrawal, or a check deposit, or an electronic payment.
Most events can be applied while only looking ahead.
When there is a <code>revert</code> event or a <code>merge</code> (which is represented as a <code>deprecates</code> and a <code>deprecatedBy</code> events), that doesn&#8217;t hold true.</p>
</div>
<div class="paragraph">
<p>We will not be modifying the aggregate in our data store.
We will however, store the event in the data store so we know when we read to read it a certain way.</p>
</div>
</div>
<div class="sect3">
<h4 id="_snapshot">Snapshot</h4>
<div class="paragraph">
<p>A snapshot is a way of looking at the state of an aggregate at a point in time.
In our banking example, this could be your account balance.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cqrs">CQRS</h3>
<div class="paragraph">
<p>Event Sourcing works particularly well with CQRS - Command Query Responsibility Segregation.
There are a couple of types of objects that are relevant to Event Sourcing and CQRS.</p>
</div>
<div class="sect3">
<h4 id="_command">Command</h4>
<div class="paragraph">
<p>A command is an input which causes one or more events to be stored.
It typically represents a broad intention of the user.</p>
</div>
</div>
<div class="sect3">
<h4 id="_query">Query</h4>
<div class="paragraph">
<p>A query is a computation that needs to be performed in order to obtain a snapshot.</p>
</div>
<div class="paragraph">
<p>A query performs a computation like the one below.</p>
</div>
<div class="stemblock">
<div class="content">
\$S_N = f(S_0, [E_1 .. E_(N)])\$
</div>
</div>
<div class="paragraph">
<p>Where</p>
</div>
<div class="ulist">
<ul>
<li>
<p>\$S_N\$ is the Snapshot computed by applying the first <code>N</code> events.</p>
</li>
<li>
<p>\$S_0\$ is the empty snapshot.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most of the time this also holds true</p>
</div>
<div class="stemblock">
<div class="content">
\$S_N = f(S_k, [E_(k+1) .. E_(N)])\$
</div>
</div>
<div class="paragraph">
<p>The second one holds true only for forward events.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_representing_events">Representing Events</h3>
<div class="paragraph">
<p>This is how we&#8217;ll be representing events in the documentation.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="SimpleEvents.svg" alt="SimpleEvents">
</div>
</div>
<div class="paragraph">
<p>The aggregate is represented by the rectangle.
It says its type and its id in the box.
Above the box is a description of the aggregate.</p>
</div>
<div class="paragraph">
<p>The circles with numbers represent events that are applied on the aggregate.
They are reasonably spaced apart to show the flow of time.
The spacing is not necessarily linear.
However when there are multiple aggregates shown together, the time lines will be in sync.</p>
</div>
<div class="paragraph">
<p>Creation events will have a dotted circle around them.
It doesn&#8217;t mean anything special.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ParallelEvents.svg" alt="ParallelEvents">
</div>
</div>
<div class="paragraph">
<p>When the time of two events is exactly the same, then they are displayed like this.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="ConcurrentEvents.svg" alt="ConcurrentEvents">
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hurdles">Hurdles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While the theory is very simple, in practice, it&#8217;s a little more complicated.
The functions that you see above are very simple at first glance, but implementing an entire system based on it requires some patterns.
That is the problem that Grooves aims to solve.</p>
</div>
<div class="sect2">
<h3 id="_completeness_of_queries">Completeness of Queries</h3>
<div class="paragraph">
<p>When applying events on a Snapshot, you need to be sure that you have handled every single event type.
Let&#8217;s say you&#8217;ve got 3 types of events for an aggregate and 2 snapshots.
If you add a new event type, you need to handle it in the computation of both snapshots.
When a language has case classes, (sealed classes in Kotlin), it&#8217;s easier to achieve this.
Alas, Groovy and Java do not have case classes.</p>
</div>
<div class="paragraph">
<p>There are some special kinds of Events that require a lot of complex handling:</p>
</div>
</div>
<div class="sect2">
<h3 id="_reverting_events">Reverting Events</h3>
<div class="paragraph">
<p>Some times events are entered into an aggregate&#8217;s timeline in error.
This could be a system error, or a human error.
When this happens, for the business logic to make sense, the system should behave as if that event never occurred.
However, for auditing purposes, and for preserving a reasonable system, the original event as well as the moment the error was detected need to be tracked.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="RevertEvent.svg" alt="RevertEvent">
</div>
</div>
<div class="paragraph">
<p>In the diagram above, we see that event 3 was performed, and later after event 4, we realized that 3 should not have occurred.
Now, we insert a special event, 5, that causes a revert of 3.
Once the system processes the data correctly, this is equivalent to what follows.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="RevertEventEffective.svg" alt="RevertEventEffective">
</div>
</div>
<div class="paragraph">
<p>Depending on how many mistakes people and systems make, this could be much more complicated.
For example, you might be able to revert a revert event.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="RevertOnRevert.svg" alt="RevertOnRevert">
</div>
</div>
<div class="paragraph">
<p>This should be interpreted as 6 cancels out 5, so 5 can no more cancel out 3.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="RevertOnRevertEffective.svg" alt="RevertOnRevertEffective">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merging_aggregates">Merging Aggregates</h3>
<div class="paragraph">
<p><code>DeprecatedBy</code> and <code>Deprecates</code> is a pair of events that work together on aggregates of the same type.
Sometimes, real world things merge together.
For example, companies get merged or acquired.
Sometimes, you accidentally create two aggregates that represent the same thing.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="MergeAggregates.svg" alt="MergeAggregates">
</div>
</div>
<div class="paragraph">
<p>In this case, we created two patients that actually represent the same person.
Then we realized that this needs to be the same person.
While reading this, we would treat it as if it was like this.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="MergeAggregatesEffective.svg" alt="MergeAggregatesEffective">
</div>
</div>
<div class="paragraph">
<p>4 is grayed out because it&#8217;s a creation event, and, this is the second creation event for the aggregate.
We will read that event, but not apply it in any meaningful way.</p>
</div>
<div class="paragraph">
<p>Typically we cannot apply any new events after 6 on Aggregate 5.
The exception to the rule is when we&#8217;re reverting the merge.
That might not always be true.
Some systems might choose to continue adding events on an aggregate like 5.</p>
</div>
</div>
<div class="sect2">
<h3 id="_reverting_merges">Reverting Merges</h3>
<div class="paragraph">
<p>Lets assume we got confused with a pair of aggregates like these and performed a merge like this.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="RevertMergeBefore.svg" alt="RevertMergeBefore">
</div>
</div>
<div class="paragraph">
<p>The correct way of reverting fixing this mistake, would be to perform a pair of reverts.
This is complicated, but necessary in order to make the reads on both aggregates result in the merge being ignored.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="RevertMergeAfter.svg" alt="RevertMergeAfter">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_performing_joins">Performing joins</h3>
<div class="paragraph">
<p>In an event sourced system, even joins are just events.
That way we can preserve their temporal changes.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="JoinExample.svg" alt="JoinExample">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_performing_disjoins">Performing disjoins</h3>
<div class="paragraph">
<p>Since joins can change with time, you could have a situation where you need to perform a <code>disjoin</code>.
In our example here, Mr Spock stops being the Science Officer when he becomes captain.
For that to happen, we need to represent that the relationship between the department Science and Mr Spock is severed at a point in time.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="DisjoinExample.svg" alt="DisjoinExample">
</div>
</div>
<div class="paragraph">
<p>You might be tempted to reuse the revert capability here.
A disjoin is different from a revert.
The difference between a disjoin and a revert is the same as the difference between a divorce and an annulment.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_how_grooves_solves_it">How Grooves solves it</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Grooves assumes nothing about your persistence framework or whether you&#8217;re building a webapp or a batch application.
Grooves only offers some tools to help you build your own event sourced system.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Interfaces for the Aggregate, Event (and its special subtypes) and Snapshot.</p>
</li>
<li>
<p>A set of interfaces with default methods that help you write queries.</p>
</li>
<li>
<p><em>If you&#8217;re using groovy</em>, annotations to mark these and AST Transformations to ensure all event types are covered in a Query implementation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This allows you to use Grooves with a lot of different frameworks.
There are examples in the repository for some options you could use.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_event_sourcing_with_grooves">Event Sourcing with Grooves</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section contains example code with annotations that indicate what is being done, and why.
We will be using 4 different kinds of projects.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Java - A java project that uses a few in memory collections as it&#8217;s storage mechanism.
It is written in Java 8, and uses JavaEE.
In the case of Java code, we&#8217;ll be skipping getters and setters to keep examples concise.
For the code to actually work, those would be required.</p>
</li>
<li>
<p>Groovy - A project that uses SpringBoot and JPA for persistence.
It&#8217;s written using Groovy. This uses RxJava2 as the Reactive Streams Framework.</p>
</li>
<li>
<p>Gorm - It&#8217;s a grails project that uses Hibernate for persisting events and aggregates.
It uses Mongo for persisting snapshots.
This is the most thorough example in our codebase.
It is the only one that demonstrates joins.</p>
</li>
<li>
<p>Kotlin - This is a SpringBoot Reactive Web project that uses RxMongo for persistence.
This example uses Spring Reactor as the Reactive Streams Framework.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_dependencies">Dependencies</h3>
<div class="paragraph">
<p>The examples here use gradle to manage dependencies.
You could very well be using Maven, or ant+ivy, or leiningen, or sbt.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
  // ... other repositories ...
  jcenter() <i class="conum" data-value="1"></i><b>(1)</b>
}
dependencies {
  // ... other dependencies ...
  compile 'com.github.rahulsom:grooves-java:0.5.0-SNAPSHOT' <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In this example, we&#8217;re using <code>jcenter</code>. You could also be using <code>mavenCentral</code>.
As long as your private artifact repository mirrors <code>mavenCentral</code>, you can use that as well.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>grooves-api</code> contains the interfaces for your queries.
It has a dependency on <code>grooves-types</code>.
That contains the interfaces for your aggregates, events, and snapshots.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
  // ... other repositories ...
  jcenter() <i class="conum" data-value="1"></i><b>(1)</b>
}
dependencies {
  // ... other dependencies ...
  compile 'com.github.rahulsom:grooves-groovy:0.5.0-SNAPSHOT' <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In this example, we&#8217;re using <code>jcenter</code>. You could also be using <code>mavenCentral</code>.
As long as your private artifact repository mirrors <code>mavenCentral</code>, you can use that as well.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>grooves-groovy</code> contains support for writing idiomatic groovy code.
It has a dependency on <code>grooves-api</code> which contains interfaces for your queries.
It also has a transitive dependency on <code>grooves-types</code>.
That contains the interfaces for your aggregates, events, and snapshots.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Gorm</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
  // ... other repositories ...
  jcenter() <i class="conum" data-value="1"></i><b>(1)</b>
}
dependencies {
  // ... other dependencies ...
  compile 'com.github.rahulsom:grooves-gorm:0.5.0-SNAPSHOT' <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In this example, we&#8217;re using <code>jcenter</code>. You could also be using <code>mavenCentral</code>.
As long as your private artifact repository mirrors <code>mavenCentral</code>, you can use that as well.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>grooves-gorm</code> contains support for simplifying access of data using gorm.
It depends on <code>grooves-groovy</code>, which contains support for writing idiomatic groovy code.
It has transitive dependencies on <code>grooves-api</code>, and <code>grooves-types</code>.
<code>grooves-api</code> contains interfaces for your queries.
<code>grooves-types</code> contains the interfaces for your aggregates, events, and snapshots.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
  // ... other repositories ...
  jcenter() <i class="conum" data-value="1"></i><b>(1)</b>
}
dependencies {
  // ... other dependencies ...
  compile 'com.github.rahulsom:grooves-api:0.5.0-SNAPSHOT' <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In this example, we&#8217;re using <code>jcenter</code>. You could also be using <code>mavenCentral</code>.
As long as your private artifact repository mirrors <code>mavenCentral</code>, you can use that as well.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>grooves-api</code> contains the interfaces for your queries.
It has a dependency on <code>grooves-types</code>.
That contains the interfaces for your aggregates, events, and snapshots.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_aggregates">Aggregates</h3>
<div class="paragraph">
<p>In our examples, to begin with, we will use one aggregate - a patient.
We&#8217;ll model our system such that there are events that get applied on a Patient&#8217;s timeline.</p>
</div>
<div class="paragraph">
<p>To uniquely identify a patient, we&#8217;re assuming, all we need is a <code>uniqueId</code>.
No name, no address, no other information.</p>
</div>
<div class="paragraph">
<p>The rest of the information will be brought in using events.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import com.github.rahulsom.grooves.java.Aggregate;
import lombok.Getter;
import lombok.Setter;

import java.io.Serializable;

@Aggregate <i class="conum" data-value="1"></i><b>(1)</b>
public class Patient implements Serializable {
    @Getter @Setter private Long id;
    @Getter @Setter private String uniqueId;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This annotation will assist in checking for completeness of queries.
There are two other annotations we&#8217;ll see - <code>@Event</code> and <code>@Query</code>.
Together, the three will help us ensure that our queries cover all events.
This is optional, but highly recommended.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode
import groovy.transform.ToString

import javax.persistence.*

@Entity
@Table(uniqueConstraints = [
        @UniqueConstraint(name = 'UK_PATIENT_UNIQUEID', columnNames = ['uniqueId']),
])
@ToString(includeSuperProperties = true, includeNames = true, includePackage = false)
@JsonIgnoreProperties(['hibernateLazyInitializer', 'handler'])
@Aggregate <i class="conum" data-value="1"></i><b>(1)</b>
class Patient {
    @GeneratedValue @Id Long id
    String uniqueId
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This annotation will assist in checking for completeness of queries.
There are two other annotations we&#8217;ll see - <code>@Event</code> and <code>@Query</code>.
Together, the three will help us ensure that our queries cover all events.
This is optional, but highly recommended.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Gorm</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">import groovy.transform.EqualsAndHashCode

@Aggregate <i class="conum" data-value="1"></i><b>(1)</b>
@EqualsAndHashCode(includes = ['uniqueId'])
class Patient implements GormAggregate&lt;Long&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

    // Long id <i class="conum" data-value="3"></i><b>(3)</b>
    String uniqueId
    static constraints = {
    }

    @Override String toString() { "Patient($id, $uniqueId)" }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This annotation will assist in checking for completeness of queries.
There are two other annotations we&#8217;ll see - <code>@Event</code> and <code>@Query</code>.
Together, the three will help us ensure that our queries cover all events.
This is optional, but highly recommended.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For grooves to use an aggregate, you must implement the <code>GormAggregate</code> interface.
It accepts a type using generics that identifies the <code>id</code> of the aggregate.
That is typically used as the primary key in a database.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This is commented out, because it is implicit in grails with a type of <code>Long</code>.
If it is implicit for your codebase, you do not have to declare it.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class Patient(var uniqueId: String? = null) { <i class="conum" data-value="1"></i><b>(1)</b>
    var id: String? = null
    override fun toString() = "Patient(uniqueId=$uniqueId, id=$id)"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since 0.5.0, there isn&#8217;t really anything special to do for declaring Aggregates.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_events">Events</h3>
<div class="paragraph">
<p>In our example, we&#8217;re going to have a bunch of events that will modify the computed state of the <code>Patient</code>.</p>
</div>
<div class="sect3">
<h4 id="_your_base_event">Your Base Event</h4>
<div class="paragraph">
<p>Let&#8217;s start with the PatientEvent first.
<code>PatientEvent</code> is the base event for all events related to <code>Patient</code>.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Some imports omitted

public abstract class PatientEvent implements BaseEvent&lt;Patient, Long, PatientEvent&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    @Getter @Setter private Patient aggregate;
    @Getter @Setter private Long id;
    @Getter @Setter
    private RevertEvent&lt;Patient, Long, PatientEvent&gt; revertedBy;  <i class="conum" data-value="2"></i><b>(2)</b>
    @Getter @Setter private Date timestamp; <i class="conum" data-value="3"></i><b>(3)</b>
    @Getter @Setter private long position; <i class="conum" data-value="4"></i><b>(4)</b>

    @Override
    @NotNull
    public Publisher&lt;Patient&gt; getAggregateObservable() { <i class="conum" data-value="5"></i><b>(5)</b>
        return toPublisher(aggregate != null ? just(aggregate) : empty());
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You&#8217;ll have to extend <code>BaseEvent</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is typically transient from a persistence perspective.
Since we&#8217;re using collections for persistence, it doesn&#8217;t make much difference.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Timestamp is used for time based filtering and ordering</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Position is used for version based filtering and ordering.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The aggregate observable allows for lazy fetching of the aggregate.
Again, since we&#8217;re using collections, it doesn&#8217;t matter.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">// All imports omitted
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = 'eventType')
@SuppressWarnings(['AbstractClassWithoutAbstractMethod'])
abstract class PatientEvent implements BaseEvent&lt;Patient, Long, PatientEvent&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    @GeneratedValue @Id Long id
    @Transient RevertEvent&lt;Patient, Long, PatientEvent&gt; revertedBy <i class="conum" data-value="2"></i><b>(2)</b>
    @Column(nullable = false) Date timestamp <i class="conum" data-value="3"></i><b>(3)</b>
    @Column(nullable = false) long position <i class="conum" data-value="4"></i><b>(4)</b>
    @OneToOne Patient aggregate

    Publisher&lt;Patient&gt; getAggregateObservable() { <i class="conum" data-value="5"></i><b>(5)</b>
        aggregate ? just(aggregate) : empty()
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You&#8217;ll have to extend <code>BaseEvent</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is transient from a persistence perspective.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Timestamp is used for time based filtering and ordering</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Position is used for version based filtering and ordering.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The aggregate observable allows for lazy fetching of the aggregate.
In our case, it doesn&#8217;t matter much since we&#8217;re using JPA, which is blocking in nature.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Gorm</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">// All imports omitted
abstract class PatientEvent implements BaseEvent&lt;Patient, Long, PatientEvent&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    Long id
    RevertEvent&lt;Patient, Long, PatientEvent&gt; revertedBy  <i class="conum" data-value="2"></i><b>(2)</b>
    Date timestamp  <i class="conum" data-value="3"></i><b>(3)</b>
    long position  <i class="conum" data-value="4"></i><b>(4)</b>
    Patient aggregate
    Publisher&lt;Patient&gt; getAggregateObservable() {
        toPublisher(aggregate ? just(aggregate) : empty())
    }  <i class="conum" data-value="5"></i><b>(5)</b>

    static transients = ['revertedBy'] <i class="conum" data-value="6"></i><b>(6)</b>

    static constraints = {
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You&#8217;ll have to extend <code>BaseEvent</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This is transient from a persistence perspective. Look at &lt;6&gt;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Timestamp is used for time based filtering and ordering</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Position is used for version based filtering and ordering.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The aggregate observable allows for lazy fetching of the aggregate.
In our case, it doesn&#8217;t matter much since we&#8217;re using Hibernate, which is blocking in nature.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// All imports omitted
sealed class PatientEvent : BaseEvent&lt;Patient, String, PatientEvent&gt; { <i class="conum" data-value="1"></i><b>(1)</b><i class="conum" data-value="2"></i><b>(2)</b>

    @Id
    override val id: String? = null

    var aggregateId: String? = null

    @Transient
    override var revertedBy: RevertEvent&lt;Patient, String, PatientEvent&gt;? = null <i class="conum" data-value="3"></i><b>(3)</b>

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    override lateinit var timestamp: Date <i class="conum" data-value="4"></i><b>(4)</b>
    override var position: Long = 0 <i class="conum" data-value="5"></i><b>(5)</b>

    fun getType(): String = this.javaClass.simpleName

    @JsonIgnore
    override fun getAggregateObservable(): Publisher&lt;Patient&gt; = <i class="conum" data-value="6"></i><b>(6)</b>
        aggregateId?.let {
            BeansHolder.context?.getBean(PatientRepository::class.java)?.findById(it)
        } ?: empty()

    override var aggregate: Patient?
        @JsonIgnore
        get() = Mono.from(getAggregateObservable()).block()
        set(value) {
            aggregateId = value!!.id
        }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We&#8217;re using sealed classes in Kotlin.
We&#8217;ll add more classes inside of it as we progress.
This helps us achieve completeness without the need to customize the compilation.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>You&#8217;ll have to extend <code>BaseEvent</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This is transient from a persistence perspective.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Timestamp is used for time based filtering and ordering</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Position is used for version based filtering and ordering.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The aggregate observable allows for lazy fetching of the aggregate.
In our case, it doesn&#8217;t matter much since we&#8217;re using Hibernate, which is blocking in nature.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_your_business_events">Your business events</h4>
<div class="paragraph">
<p>Next up, let&#8217;s look at our first event, <code>PatientCreated</code>.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Event(Patient.class) <i class="conum" data-value="1"></i><b>(1)</b>
public class PatientCreated extends PatientEvent { <i class="conum" data-value="2"></i><b>(2)</b>
    @Getter private final String name;

    public PatientCreated(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Event</code> annotation is the second step to achieving completeness of events.
It accepts as a param, the Aggregate over which it applies.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For most events you&#8217;re interested in as a user, you&#8217;ll just have to extend <code>PatientEvent</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@Entity
@Event(Patient) <i class="conum" data-value="1"></i><b>(1)</b>
class PatientCreated extends PatientEvent { <i class="conum" data-value="2"></i><b>(2)</b>
    String name

    @Override String toString() { "PatientCreated(name=$name)" }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Event</code> annotation is the second step to achieving completeness of events.
It accepts as a param, the Aggregate over which it applies.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For most events you&#8217;re interested in as a user, you&#8217;ll just have to extend <code>PatientEvent</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Gorm</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@Event(Patient) <i class="conum" data-value="1"></i><b>(1)</b>
class PatientCreated extends PatientEvent { <i class="conum" data-value="2"></i><b>(2)</b>
    String name

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@Event</code> annotation is the second step to achieving completeness of events.
It accepts as a param, the Aggregate over which it applies.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For most events you&#8217;re interested in as a user, you&#8217;ll just have to extend <code>PatientEvent</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">sealed class PatientEvent : BaseEvent&lt;...&gt; {
    // ... skipping stuff already there ...
    sealed class Applicable : PatientEvent() { <i class="conum" data-value="1"></i><b>(1)</b>
        data class Created(val name: String) : Applicable() { <i class="conum" data-value="2"></i><b>(2)</b>
            fun getAudit(): String = "$id - Created '$name'"
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>First we create a sealed class within the <code>PatientEvent</code> called <code>Applicable</code>.
What we call it doesn&#8217;t matter.
All application events will go there.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>For most events you&#8217;re interested in as a user, you&#8217;ll just have to extend <code>Applicable</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In our example, we&#8217;ll have two more business events.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ProcedurePerformed</code> that gives you a procedure code and the cost</p>
</li>
<li>
<p><code>PaymentMade</code> which gives you the amount paid</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please look at the source to see how they are implemented.</p>
</div>
</div>
<div class="sect3">
<h4 id="_standard_grooves_events">Standard Grooves Events</h4>
<div class="paragraph">
<p>There are some Standard Grooves Events - JoinEvent, DisjoinEvent, DeprecatedBy, Deprecates, RevertEvent.
Their implementation is similar to one another, but slightly different from your business events.</p>
</div>
<div class="paragraph">
<p>We are going to walk through the <code>RevertEvent</code> over here.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import com.github.rahulsom.grooves.api.events.RevertEvent;
import lombok.Getter;

public class PatientEventReverted extends PatientEvent <i class="conum" data-value="1"></i><b>(1)</b>
        implements RevertEvent&lt;Patient, Long, PatientEvent&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
    @Getter private final Long revertedEventId; <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Like your business events, you&#8217;ll extend <code>PatientEvent</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In addition, you&#8217;ll implement the <code>RevertEvent</code> interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>And you&#8217;ll have to give it a property <code>revertedEventId</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@Entity
class PatientEventReverted extends PatientEvent <i class="conum" data-value="1"></i><b>(1)</b>
        implements RevertEvent&lt;Patient, Long, PatientEvent&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
    Long revertedEventId <i class="conum" data-value="3"></i><b>(3)</b>

    @Override String toString() { "PatientEventReverted(revertedEventId=$revertedEventId)" }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Like your business events, you&#8217;ll extend <code>PatientEvent</code>.
You do not need to annotate it as an Event.
Even if you do, you cannot process this event.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In addition, you&#8217;ll implement the <code>RevertEvent</code> interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>And you&#8217;ll have to give it a property <code>revertedEventId</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Gorm</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@EqualsAndHashCode
class PatientEventReverted extends PatientEvent <i class="conum" data-value="1"></i><b>(1)</b>
        implements RevertEvent&lt;Patient, Long, PatientEvent&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
    Long revertedEventId <i class="conum" data-value="3"></i><b>(3)</b>

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Like your business events, you&#8217;ll extend <code>PatientEvent</code>.
You do not need to annotate it as an Event.
Even if you do, you cannot process this event.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>In addition, you&#8217;ll implement the <code>RevertEvent</code> interface.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>And you&#8217;ll have to give it a property <code>revertedEventId</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">sealed class PatientEvent : BaseEvent&lt;...&gt; {
    // ... skipping stuff already there ...
    data class Reverted(override val revertedEventId: String) : <i class="conum" data-value="1"></i><b>(1)</b>
        PatientEvent(), <i class="conum" data-value="2"></i><b>(2)</b>
        RevertEvent&lt;Patient, String, PatientEvent&gt; { <i class="conum" data-value="3"></i><b>(3)</b>
        fun getAudit(): String = "$id - Revert $revertedEventId"
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You&#8217;ll have to give it a property <code>revertedEventId</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Like your <code>Applicable</code> in business events, you&#8217;ll extend <code>PatientEvent</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>In addition, you&#8217;ll implement the <code>RevertEvent</code> interface.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_snapshots">Snapshots</h3>
<div class="paragraph">
<p>Let&#8217;s start with a snapshot that manages account balance for a patient.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class PatientAccount implements Snapshot&lt;Patient, Long, Long, PatientEvent&gt;, <i class="conum" data-value="1"></i><b>(1)</b>
        Serializable {
    @Getter @Setter private Long id;
    @Getter @Setter private Patient aggregate;
    @Getter @Setter private Patient deprecatedBy;
    @Getter @Setter private List&lt;Patient&gt; deprecates = new ArrayList&lt;&gt;();
    @Getter @Setter private long lastEventPosition; <i class="conum" data-value="2"></i><b>(2)</b>
    @Getter @Setter private Date lastEventTimestamp; <i class="conum" data-value="3"></i><b>(3)</b>

    @Getter @Setter private String name;
    @Getter @Setter private BigDecimal balance = new BigDecimal(0);
    @Getter @Setter private BigDecimal moneyMade = new BigDecimal(0);

    public Publisher&lt;Patient&gt; getAggregateObservable() { <i class="conum" data-value="4"></i><b>(4)</b>
        return toPublisher(aggregate != null ? just(aggregate) : empty());
    }

    public Publisher&lt;Patient&gt; getDeprecatedByObservable() { <i class="conum" data-value="5"></i><b>(5)</b>
        return toPublisher(deprecatedBy != null ? just(deprecatedBy) : empty());
    }

    public Publisher&lt;Patient&gt; getDeprecatesObservable() { <i class="conum" data-value="6"></i><b>(6)</b>
        return toPublisher(from(deprecates));
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>For most snapshots, you may implement <code>Snapshot</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>lastEventPosition</code> is useful when locating snapshots by version.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>lastEventTimestamp</code> is useful when locating snapshots by timestamp.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>aggregateObservable</code> getter points to the aggregate from the snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>deprecatedByObservable</code> points to the deprecator of the snapshot&#8217;s aggregate.
It is empty when the aggregate is not deprecated.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The <code>deprecatesObservable</code> points to the aggregates deprecated by snapshot&#8217;s aggregate.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class PatientAccount implements Snapshot&lt;Patient, Long, Long, PatientEvent&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    @GeneratedValue @Id Long id

    @Column(nullable = false) long lastEventPosition <i class="conum" data-value="2"></i><b>(2)</b>

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    @Column(nullable = false) Date lastEventTimestamp <i class="conum" data-value="3"></i><b>(3)</b>

    @OneToOne Patient deprecatedBy
    @OneToMany @JoinTable(name = 'PatientAccountDeprecates') Set&lt;Patient&gt; deprecates
    @OneToOne Patient aggregate

    @Column(nullable = false) BigDecimal balance = 0.0
    @Column(nullable = false) BigDecimal moneyMade = 0.0
    @Column(nullable = false) String name

    int processingErrors = 0

    @Override @JsonIgnore Publisher&lt;Patient&gt; getAggregateObservable() { <i class="conum" data-value="4"></i><b>(4)</b>
        aggregate ? just(aggregate) : empty()
    }

    @Override @JsonIgnore Publisher&lt;Patient&gt; getDeprecatedByObservable() { <i class="conum" data-value="5"></i><b>(5)</b>
        deprecatedBy ? just(deprecatedBy) : empty()
    }

    @Override @JsonIgnore Publisher&lt;Patient&gt; getDeprecatesObservable() { <i class="conum" data-value="6"></i><b>(6)</b>
        fromIterable(deprecates.toList())
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>For most snapshots, you may implement <code>Snapshot</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>lastEventPosition</code> is useful when locating snapshots by version.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>lastEventTimestamp</code> is useful when locating snapshots by timestamp.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>aggregateObservable</code> getter points to the aggregate from the snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>deprecatedByObservable</code> points to the deprecator of the snapshot&#8217;s aggregate.
It is empty when the aggregate is not deprecated.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The <code>deprecatesObservable</code> points to the aggregates deprecated by snapshot&#8217;s aggregate.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Gorm</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class PatientAccount implements Snapshot&lt;Patient, String, Long, PatientEvent&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    static mapWith = 'mongo'

    String id
    long lastEventPosition <i class="conum" data-value="2"></i><b>(2)</b>
    Date lastEventTimestamp <i class="conum" data-value="3"></i><b>(3)</b>
    Set&lt;String&gt; processingErrors = []

    Long aggregateId

    Patient getAggregate() { Patient.get(aggregateId) }

    @Override
    Publisher&lt;Patient&gt; getAggregateObservable() { <i class="conum" data-value="4"></i><b>(4)</b>
        toPublisher(aggregateId ? defer { just aggregate } : empty())
    }

    void setAggregate(Patient aggregate) { this.aggregateId = aggregate.id }

    @Override
    Publisher&lt;Patient&gt; getDeprecatedByObservable() { <i class="conum" data-value="5"></i><b>(5)</b>
        toPublisher(deprecatedBy ? just(deprecatedBy) : empty())
    }
    Long deprecatedById

    Patient getDeprecatedBy() { Patient.get(deprecatedById) }

    void setDeprecatedBy(Patient aggregate) { deprecatedById = aggregate.id }

    @Override
    Publisher&lt;Patient&gt; getDeprecatesObservable() { <i class="conum" data-value="6"></i><b>(6)</b>
        toPublisher(deprecatesIds ? from(deprecatesIds).flatMap { Patient.get it } : empty())
    }
    Set&lt;Long&gt; deprecatesIds

    Set&lt;Patient&gt; getDeprecates() { deprecatesIds.collect { Patient.get(it) }.toSet() }

    void setDeprecates(Set&lt;Patient&gt; deprecates) { deprecatesIds = deprecates*.id }

    BigDecimal balance = 0.0
    BigDecimal moneyMade = 0.0

    String name

    static hasMany = [
            deprecatesIds: Long,
    ]

    static embedded = ['deprecates', 'processingErrors',]
    static transients = ['aggregate', 'deprecatedBy', 'deprecates',]

    static constraints = {
        deprecatedById nullable: true
    }

    @Override String toString() {
        "PatientAccount(id=$id, aggregateId=$aggregateId, lastEventPosition=$lastEventPosition, " +
                "balance=$balance, moneyMade=$moneyMade)"
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>For most snapshots, you may implement <code>Snapshot</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>lastEventPosition</code> is useful when locating snapshots by version.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>lastEventTimestamp</code> is useful when locating snapshots by timestamp.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>aggregateObservable</code> getter points to the aggregate from the snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>deprecatedByObservable</code> points to the deprecator of the snapshot&#8217;s aggregate.
It is empty when the aggregate is not deprecated.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The <code>deprecatesObservable</code> points to the aggregates deprecated by snapshot&#8217;s aggregate.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Configurable
class PatientAccount : Snapshot&lt;Patient, String, String, PatientEvent&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    override var id: String? = null
    override var lastEventPosition: Long = 0 <i class="conum" data-value="2"></i><b>(2)</b>

    @JsonFormat(pattern = "yyyy-MM-dd'T'HH:mm:ss.SSSZ")
    override var lastEventTimestamp: Date? = null<i class="conum" data-value="3"></i><b>(3)</b>
    val deprecatesIds: MutableList&lt;String&gt; = mutableListOf()
    private var deprecator: Patient? = null
    var aggregateId: String? = null

    var name: String? = null
    var balance: BigDecimal = BigDecimal.ZERO
    var moneyMade: BigDecimal = BigDecimal.ZERO

    fun getDeprecatedBy() = deprecator

    @JsonIgnore
    override fun getAggregateObservable() = <i class="conum" data-value="4"></i><b>(4)</b>
        aggregateId?.let { patientRepository!!.findAllById(just(it)) } ?: Flux.empty()

    override fun setAggregate(aggregate: Patient) {
        this.aggregateId = aggregate.id
    }

    @JsonIgnore
    @Autowired
    var patientRepository: PatientRepository? = null

    @JsonIgnore
    override fun getDeprecatedByObservable() = <i class="conum" data-value="5"></i><b>(5)</b>
        deprecator?.let { just(it) } ?: Mono.empty()

    override fun setDeprecatedBy(deprecatingAggregate: Patient) {
        deprecator = deprecatingAggregate
    }

    @JsonIgnore
    override fun getDeprecatesObservable() = <i class="conum" data-value="6"></i><b>(6)</b>
        if (deprecatesIds.size &gt; 0)
            patientRepository!!.findAllById(deprecatesIds)
        else
            empty()

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>For most snapshots, you may implement <code>Snapshot</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>lastEventPosition</code> is useful when locating snapshots by version.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>lastEventTimestamp</code> is useful when locating snapshots by timestamp.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The <code>aggregateObservable</code> getter points to the aggregate from the snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>deprecatedByObservable</code> points to the deprecator of the snapshot&#8217;s aggregate.
It is empty when the aggregate is not deprecated.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The <code>deprecatesObservable</code> points to the aggregates deprecated by snapshot&#8217;s aggregate.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The reason for <code>aggregateObservable</code>, <code>deprecatedByObservable</code> and <code>deprecatesObservable</code> being <code>rx.Observable</code> is to allow asynchronous data access layers to work well.</p>
</div>
<div class="paragraph">
<p>In our examples, we have one more snapshot - <code>PatientHealth</code> which lists codes for procedures and the dates they were performed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_queries">Queries</h3>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// You don't need to have an intermediate type to manage your queries, but it does make code reuse better.
public interface CustomQuerySupport&lt;
        SnapshotT extends Snapshot&lt;Patient, Long, Long, PatientEvent&gt; &amp; Serializable <i class="conum" data-value="1"></i><b>(1)</b>
        &gt; extends QuerySupport&lt;Patient, Long, PatientEvent, Long, SnapshotT&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

    @Override
    default Publisher&lt;SnapshotT&gt; getSnapshot(long maxPosition, @NotNull Patient aggregate) {
        <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @NotNull
    @Override
    default Publisher&lt;SnapshotT&gt; getSnapshot(
            @Nullable Date maxTimestamp, @NotNull Patient aggregate) {
        <i class="conum" data-value="4"></i><b>(4)</b>
    }
    @Override
    default boolean shouldEventsBeApplied(@NotNull SnapshotT snapshot) { <i class="conum" data-value="5"></i><b>(5)</b>
        return true;
    }

    @NotNull
    @Override
    default Publisher&lt;EventApplyOutcome&gt; onException(
            @NotNull Exception e, @NotNull SnapshotT snapshot, @NotNull PatientEvent event) { <i class="conum" data-value="6"></i><b>(6)</b>
        getLog().error("Error computing snapshot", e);
        return toPublisher(just(CONTINUE));
    }

    @NotNull
    @Override
    default Publisher&lt;PatientEvent&gt; getUncomputedEvents(
            @NotNull Patient aggregate, @Nullable SnapshotT lastSnapshot, long version) {
        <i class="conum" data-value="7"></i><b>(7)</b>
    }

    @NotNull
    @Override
    default Publisher&lt;PatientEvent&gt; getUncomputedEvents(
            @NotNull Patient aggregate, @Nullable SnapshotT lastSnapshot,
            @NotNull Date snapshotTime) {
        <i class="conum" data-value="8"></i><b>(8)</b>
    }

}
// This is the implementation we need
@Query(aggregate = Patient.class, snapshot = PatientAccount.class) <i class="conum" data-value="9"></i><b>(9)</b>
public class PatientAccountQuery
        implements CustomQuerySupport&lt;PatientAccount&gt; { <i class="conum" data-value="10"></i><b>(10)</b>

    @NotNull
    @Override
    public PatientAccount createEmptySnapshot() { <i class="conum" data-value="11"></i><b>(11)</b>
        return new PatientAccount();
    }
    public Publisher&lt;EventApplyOutcome&gt; applyPatientCreated(
            PatientCreated event, PatientAccount snapshot) { <i class="conum" data-value="12"></i><b>(12)</b>
        if (snapshot.getAggregate() == event.getAggregate()) {
            snapshot.setName(event.getName());
        }
        return toPublisher(just(CONTINUE)); <i class="conum" data-value="13"></i><b>(13)</b>
    }

    public Publisher&lt;EventApplyOutcome&gt; applyProcedurePerformed(
            ProcedurePerformed event, PatientAccount snapshot) {
        final double cost = event.getCost().doubleValue();
        final double originalBalance = snapshot.getBalance().doubleValue();

        snapshot.setBalance(BigDecimal.valueOf(originalBalance + cost));

        return toPublisher(just(CONTINUE));
    }

    public Publisher&lt;EventApplyOutcome&gt; applyPaymentMade(
            PaymentMade event, PatientAccount snapshot) {

        final double amount = event.getAmount().doubleValue();
        final double originalBalance = snapshot.getBalance().doubleValue();
        final double originalMoneyMade = snapshot.getMoneyMade().doubleValue();

        snapshot.setBalance(BigDecimal.valueOf(originalBalance - amount));
        snapshot.setMoneyMade(BigDecimal.valueOf(originalMoneyMade + amount));

        return toPublisher(just(CONTINUE));
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is a placeholder for the snapshot we&#8217;ll compute.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>QuerySupport</code> allows computing both temporal and versioned snapshots.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The implementation of this method will return a snapshot that&#8217;s older than the <code>maxPosition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The implementation of this method will return a snapshot that&#8217;s older than the <code>maxTimestamp</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This allows the query to have some control over when to stop applying events on a snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This is an exception handler.
You can decide to <code>CONTINUE</code> or <code>RETURN</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The implementation of this method must return all events for an aggregate that are more recent than the last event of <code>lastSnapshot</code>, but lead up to <code>version</code>.
Think of the range as exclusive of <code>lastSnapshot</code>, but inclusive of <code>version</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The implementation of this method must return all events for an aggregate that are more recent than the last event of <code>lastSnapshot</code>, but lead up to <code>snapshotTime</code>.
Think of the range as exclusive of <code>lastSnapshot</code>, but inclusive of <code>snapshotTime</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>This annotation is the final step in verification of completeness.
The AST Transformation checks that all <code>@Event</code> s associated with the <code>@Aggregate</code> are accounted for in the <code>@Query</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Here we implement our default interface</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>This method gets called if no prior snapshot that is usable is found.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>We name our methods <code>apply&lt;EventType&gt;</code>.
This is required.
It is not enforced though.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Each of these methods takes the event and the snapshot as inputs and returns an <code>Publisher&lt;EventApplyOutcome&gt;</code> as output.
It can <code>CONTINUE</code> or <code>RETURN</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">@Query(aggregate = Patient, snapshot = PatientAccount) <i class="conum" data-value="1"></i><b>(1)</b>
class PatientAccountQuery implements
        QuerySupport&lt;Patient, Long, PatientEvent, Long, PatientAccount&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

    @Override
    Publisher&lt;PatientAccount&gt; getSnapshot(long maxPosition, Patient aggregate) { <i class="conum" data-value="3"></i><b>(3)</b>
    }

    @Override
    Publisher&lt;PatientAccount&gt; getSnapshot(Date maxTimestamp, Patient aggregate) { <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Override
    boolean shouldEventsBeApplied(PatientAccount snapshot) { <i class="conum" data-value="5"></i><b>(5)</b>
        true
    }

    @Override
    Publisher&lt;EventApplyOutcome&gt; onException(
            Exception e, PatientAccount snapshot, PatientEvent event) { <i class="conum" data-value="6"></i><b>(6)</b>
        snapshot.processingErrors++
        just(CONTINUE)
    }

    @Override
    Publisher&lt;PatientEvent&gt; getUncomputedEvents(
            Patient patient, PatientAccount lastSnapshot, long version) { <i class="conum" data-value="7"></i><b>(7)</b>
    }

    @NotNull
    @Override Publisher&lt;PatientEvent&gt; getUncomputedEvents(
            Patient aggregate, PatientAccount lastSnapshot, Date snapshotTime) { <i class="conum" data-value="8"></i><b>(8)</b>
    }

    @NotNull
    @Override PatientAccount createEmptySnapshot() { <i class="conum" data-value="9"></i><b>(9)</b>
        new PatientAccount(deprecates: [])
    }

    @Override
    void addToDeprecates(@NotNull PatientAccount snapshot, Patient deprecatedAggregate) {
        snapshot.deprecates &lt;&lt; deprecatedAggregate
    }

    Publisher&lt;EventApplyOutcome&gt; applyPatientCreated(
            PatientCreated event, PatientAccount snapshot) { <i class="conum" data-value="10"></i><b>(10)</b>
        if (snapshot.aggregate == event.aggregate) {
            snapshot.name = event.name
        }
        just(CONTINUE) <i class="conum" data-value="11"></i><b>(11)</b>
    }

    Publisher&lt;EventApplyOutcome&gt; applyProcedurePerformed(
            ProcedurePerformed event, PatientAccount snapshot) {
        snapshot.balance += event.cost
        just(CONTINUE)
    }

    Publisher&lt;EventApplyOutcome&gt; applyPaymentMade(
            PaymentMade event, PatientAccount snapshot) {
        snapshot.balance -= event.amount
        snapshot.moneyMade += event.amount
        just(CONTINUE)
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This annotation is the final step in verification of completeness.
The AST Transformation checks that all <code>@Event</code> s associated with the <code>@Aggregate</code> are accounted for in the <code>@Query</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>QuerySupport</code> allows computing both temporal and versioned snapshots.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The implementation of this method will return a snapshot that&#8217;s older than the <code>maxPosition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The implementation of this method will return a snapshot that&#8217;s older than the <code>maxTimestamp</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This allows the query to have some control over when to stop applying events on a snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This is an exception handler.
You can decide to <code>CONTINUE</code> or <code>RETURN</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>The implementation of this method must return all events for an aggregate that are more recent than the last event of <code>lastSnapshot</code>, but lead up to <code>version</code>.
Think of the range as exclusive of <code>lastSnapshot</code>, but inclusive of <code>version</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>The implementation of this method must return all events for an aggregate that are more recent than the last event of <code>lastSnapshot</code>, but lead up to <code>snapshotTime</code>.
Think of the range as exclusive of <code>lastSnapshot</code>, but inclusive of <code>snapshotTime</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>This method gets called if no prior snapshot that is usable is found.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>We name our methods <code>apply&lt;EventType&gt;</code>.
This is required.
Your IDE might not point out if you don&#8217;t do it right, but the compiler will.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Each of these methods takes the event and the snapshot as inputs and returns an <code>Publisher&lt;EventApplyOutcome&gt;</code> as output.
It can <code>CONTINUE</code> or <code>RETURN</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Gorm</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">// You don't need to have an intermediate type to manage your queries, but it does make code reuse better.
// Also this is written in java.
public interface GormQuerySupport&lt;
        AggregateIdT,
        AggregateT extends GormAggregate&lt;AggregateIdT&gt; &amp; GormEntity&lt;AggregateT&gt;,
        EventIdT,
        EventT extends BaseEvent&lt;AggregateT, EventIdT, EventT&gt; &amp; GormEntity&lt;EventT&gt;,
        SnapshotIdT,
        SnapshotT extends Snapshot&lt;AggregateT, SnapshotIdT, EventIdT, EventT&gt; &amp;
                GormEntity&lt;SnapshotT&gt;
        &gt; extends QuerySupport&lt;AggregateT, EventIdT, EventT, SnapshotIdT, SnapshotT&gt;, <i class="conum" data-value="1"></i><b>(1)</b>
        BlockingEventSource&lt;AggregateT, EventIdT, EventT, SnapshotIdT, SnapshotT&gt;,
        BlockingSnapshotSource&lt;AggregateIdT, AggregateT, EventIdT, EventT, SnapshotIdT, SnapshotT&gt; {

    Class&lt;EventT&gt; getEventClass(); <i class="conum" data-value="2"></i><b>(2)</b>

    Class&lt;SnapshotT&gt; getSnapshotClass(); <i class="conum" data-value="3"></i><b>(3)</b>

    @NotNull
    @Override
    default Publisher&lt;SnapshotT&gt; getSnapshot(long maxPosition, @NotNull AggregateT aggregate) {
        return BlockingSnapshotSource.super
                .getSnapshot(maxPosition, aggregate); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @NotNull
    @Override
    default Publisher&lt;SnapshotT&gt; getSnapshot(Date maxTimestamp, @NotNull AggregateT aggregate) {
        return BlockingSnapshotSource.super
                .getSnapshot(maxTimestamp, aggregate);
    }

    @NotNull
    @Override
    default Publisher&lt;EventT&gt; getUncomputedEvents(
            @NotNull AggregateT aggregate, @Nullable SnapshotT lastSnapshot, long version) {
        return BlockingEventSource.super
                .getUncomputedEvents(aggregate, lastSnapshot, version);
    }

    @NotNull
    @Override
    default Publisher&lt;EventT&gt; getUncomputedEvents(
            @NotNull AggregateT aggregate, @Nullable SnapshotT lastSnapshot,
            @NotNull Date snapshotTime) {
        return BlockingEventSource.super
                .getUncomputedEvents(aggregate, lastSnapshot, snapshotTime);
    }

}
// This is the implementation we need here
@Query(aggregate = Patient, snapshot = PatientAccount) <i class="conum" data-value="5"></i><b>(5)</b>
class PatientAccountQuery
        implements GormQuerySupport&lt;Long, Patient, Long, PatientEvent,
                String, PatientAccount&gt; { <i class="conum" data-value="6"></i><b>(6)</b>

    final Class&lt;PatientEvent&gt; eventClass = PatientEvent <i class="conum" data-value="7"></i><b>(7)</b>
    final Class&lt;PatientAccount&gt; snapshotClass = PatientAccount <i class="conum" data-value="8"></i><b>(8)</b>

    @Override
    PatientAccount createEmptySnapshot() { new PatientAccount(deprecates: []) } <i class="conum" data-value="9"></i><b>(9)</b>

    @Override
    boolean shouldEventsBeApplied(PatientAccount snapshot) { <i class="conum" data-value="10"></i><b>(10)</b>
        true
    }

    @Override
    void addToDeprecates(PatientAccount snapshot, Patient deprecatedAggregate) {
        snapshot.addToDeprecatesIds(deprecatedAggregate.id)
    }

    @Override
    Publisher&lt;EventApplyOutcome&gt; onException( <i class="conum" data-value="11"></i><b>(11)</b>
            Exception e, PatientAccount snapshot, PatientEvent event) {
        snapshot.processingErrors &lt;&lt; e.message
        toPublisher(just(CONTINUE))
    }

    Publisher&lt;EventApplyOutcome&gt; applyPatientCreated( <i class="conum" data-value="12"></i><b>(12)</b>
            PatientCreated event, PatientAccount snapshot) {
        if (snapshot.aggregateId == event.aggregate.id) {
            snapshot.name = event.name
        }
        toPublisher(just(CONTINUE)) <i class="conum" data-value="13"></i><b>(13)</b>
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>QuerySupport</code> allows computing both temporal and versioned snapshots.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>BlockingEventSource</code> needs an <code>eventClass</code>.
<code>BlockingEventSource</code> and <code>RxEventSource</code> greatly simplify working with events from a gorm source.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>BlockingSnapshotSource</code> needs a <code>snapshotClass</code>.
<code>BlockingSnapshotSource</code> and <code>RxSnapshotSource</code> do the same for snapshots.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This is an example of using the <code>BlockingEventSource</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This annotation is the final step in verification of completeness.
The AST Transformation checks that all <code>@Event</code> s associated with the <code>@Aggregate</code> are accounted for in the <code>@Query</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Here we&#8217;ll implement the interface we just wrote.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This configures the event class.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>This configures the snapshot class.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>This method gets called if no prior snapshot that is usable is found.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>This allows the query to have some control over when to stop applying events on a snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>This is an exception handler.
You can decide to <code>CONTINUE</code> or <code>RETURN</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>We name our methods <code>apply&lt;EventType&gt;</code>.
This is required.
Your IDE might not point out if you don&#8217;t do it right, but the compiler will.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Each of these methods takes the event and the snapshot as inputs and returns an <code>Publisher&lt;EventApplyOutcome&gt;</code> as output.
It can <code>CONTINUE</code> or <code>RETURN</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class PatientAccountQuery constructor(
    @Autowired val patientEventRepository: PatientEventRepository,
    @Autowired val patientAccountRepository: PatientAccountRepository
) :
    QuerySupport&lt;Patient, String, PatientEvent, String, PatientAccount&gt;, <i class="conum" data-value="1"></i><b>(1)</b>
    SimpleQuery&lt;Patient, String, PatientEvent, PatientEvent.Applicable, String,
            PatientAccount&gt; { <i class="conum" data-value="2"></i><b>(2)</b>

    override fun getExecutor() = SimpleExecutor&lt;Patient, String, PatientEvent,
            PatientEvent.Applicable, String, PatientAccount, PatientAccountQuery&gt;() <i class="conum" data-value="3"></i><b>(3)</b>

    override fun createEmptySnapshot() = PatientAccount() <i class="conum" data-value="4"></i><b>(4)</b>

    override fun getSnapshot(<i class="conum" data-value="5"></i><b>(5)</b>
        maxPosition: Long, aggregate: Patient
    ) =
        patientAccountRepository.findByAggregateIdAndLastEventPositionLessThan(
            aggregate.id!!, maxPosition
        )

    override fun getSnapshot(<i class="conum" data-value="6"></i><b>(6)</b>
        maxTimestamp: Date?, aggregate: Patient
    ) =
        patientAccountRepository.findByAggregateIdAndLastEventTimestampLessThan(
            aggregate.id!!, maxTimestamp!!
        )

    override fun shouldEventsBeApplied(snapshot: PatientAccount) = true <i class="conum" data-value="7"></i><b>(7)</b>

    override fun addToDeprecates(
        snapshot: PatientAccount, deprecatedAggregate: Patient
    ) {
        snapshot.deprecatesIds.add(deprecatedAggregate.id!!)
    }

    override fun onException(<i class="conum" data-value="8"></i><b>(8)</b>
        e: Exception, snapshot: PatientAccount, event: PatientEvent
    ) =
        just(CONTINUE)

    override fun getUncomputedEvents(<i class="conum" data-value="9"></i><b>(9)</b>
        aggregate: Patient, lastSnapshot: PatientAccount?, version: Long
    ) =
        patientEventRepository.findAllByPositionRange(
            aggregate.id!!,
            lastSnapshot?.lastEventPosition ?: 0, version
        )

    override fun getUncomputedEvents(<i class="conum" data-value="10"></i><b>(10)</b>
        aggregate: Patient, lastSnapshot: PatientAccount?, snapshotTime: Date
    ) =
        lastSnapshot?.lastEventTimestamp?.let {
            patientEventRepository.findAllByTimestampRange(
                aggregate.id!!, it, snapshotTime
            )
        } ?: patientEventRepository.findAllByAggregateIdAndTimestampLessThan(
            aggregate.id!!, snapshotTime
        )

    override fun applyEvent(event: PatientEvent.Applicable, snapshot: PatientAccount) =
        when (event) { <i class="conum" data-value="11"></i><b>(11)</b>
            is PatientEvent.Applicable.Created -&gt; {
                if (event.aggregateId == snapshot.aggregateId) {
                    snapshot.name = event.name
                }
                just(CONTINUE)
            }
            is PatientEvent.Applicable.ProcedurePerformed -&gt; {
                snapshot.balance = snapshot.balance.add(event.cost)
                just(CONTINUE)
            }
            is PatientEvent.Applicable.PaymentMade -&gt; {
                snapshot.balance = snapshot.balance.subtract(event.amount)
                snapshot.moneyMade = snapshot.moneyMade.add(event.amount)
                just(CONTINUE)
            }
        }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>QuerySupport</code> allows computing both temporal and versioned snapshots.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>SimpleQuery</code> makes working with Kotlin better.
It calls the <code>applyEvent</code> method instead of calling <code>apply&lt;EventType&gt;</code>.
With Kotlin <code>applyEvent</code> is sufficient, because you can use sealed classes to achieve completeness.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>SimpleExecutor</code> is what wires up <code>SimpleQuery</code> correctly.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This method gets called if no prior snapshot that is usable is found.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The implementation of this method will return a snapshot that&#8217;s older than the <code>maxPosition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The implementation of this method will return a snapshot that&#8217;s older than the <code>maxTimestamp</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This allows the query to have some control over when to stop applying events on a snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>This is an exception handler.
You can decide to <code>CONTINUE</code> or <code>RETURN</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>The implementation of this method must return all events for an aggregate that are more recent than the last event of <code>lastSnapshot</code>, but lead up to <code>version</code>.
Think of the range as exclusive of <code>lastSnapshot</code>, but inclusive of <code>version</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>The implementation of this method must return all events for an aggregate that are more recent than the last event of <code>lastSnapshot</code>, but lead up to <code>snapshotTime</code>.
Think of the range as exclusive of <code>lastSnapshot</code>, but inclusive of <code>snapshotTime</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td><code>applyEvent</code> handles all events under <code>Applicable</code>.
Kotlin will check for completeness when you use the <code>when</code> keyword as part of an <code>expression</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_joins">Joins</h3>
<div class="paragraph">
<p>Joins are just snapshots of a different kind.
With Grooves, they&#8217;re always <em>One-To-Many</em>. <em>One-To-One</em> is just a special case of <em>One-To-Many</em>.
This is a good example for [join events] in a GORM based project.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class DoctorGotPatient extends DoctorEvent <i class="conum" data-value="1"></i><b>(1)</b>
        implements JoinEvent&lt;Doctor, Long, DoctorEvent, Patient&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
    Patient patient
    @Override Publisher&lt;Patient&gt; getJoinAggregateObservable() { toPublisher(just(patient)) }
}
class DoctorLostPatient extends DoctorEvent
        implements DisjoinEvent&lt;Doctor, Long, DoctorEvent, Patient&gt; { <i class="conum" data-value="3"></i><b>(3)</b>
    Patient patient
    @Override Publisher&lt;Patient&gt; getJoinAggregateObservable() { toPublisher(just(patient)) } <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This extends a base class corresponding to its aggregate</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This implements <code>JoinEvent</code> to mark the beginning of a join</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This class implements <code>DisjoinEvent</code> to mark the end of a join</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The method <code>getJoinAggregateObservable</code> allows redirections from deprecated aggregates.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The query used to compute a Join is slightly different.
It only concerns itself with two forward events - the <code>JoinEvent</code> and the <code>DisjoinEvent</code>.
This is a good example for such a <a href="https://github.com/rahulsom/grooves/blob/master/examples/grails/rdbms_mongo/src/main/groovy/grooves/grails/mongo/DoctorPatientsQuery.groovy">query</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">class DoctorPatientsQuery implements JoinSupport&lt; <i class="conum" data-value="1"></i><b>(1)</b>
        Doctor, <i class="conum" data-value="2"></i><b>(2)</b>
        Long, DoctorEvent, <i class="conum" data-value="3"></i><b>(3)</b>
        Patient, <i class="conum" data-value="4"></i><b>(4)</b>
        String, DoctorPatients, <i class="conum" data-value="5"></i><b>(5)</b>
        DoctorGotPatient, DoctorLostPatient <i class="conum" data-value="6"></i><b>(6)</b>
        &gt; { <i class="conum" data-value="7"></i><b>(7)</b>

    final Class disjoinEventClass = DoctorLostPatient <i class="conum" data-value="8"></i><b>(8)</b>
    final Class joinEventClass = DoctorGotPatient <i class="conum" data-value="9"></i><b>(9)</b>

    // Skipping familiar methods <i class="conum" data-value="10"></i><b>(10)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>JoinSupport</code> is similar to <code>QuerySupport</code>.
It does not require implementing methods for each event.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This says that the aggregate for which this computes joins is <code>Doctor</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This says that the base class for events for which this computes joins is <code>DoctorEvent</code> whose id is <code>Long</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This says that the joined aggregate for which this computes joins is <code>Patient</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This says that the join computed is <code>DoctorPatients</code> whose id is <code>String</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>The events that represent a join and a disjoin are <code>DoctorGotPatient</code>, <code>DoctorLostPatient</code> respectively.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This says that the class of the query is <code>DoctorPatientsQuery</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>This is another reference to the disjoin event.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>This is another reference to the join event.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Methods that you&#8217;ve seen in typical queries have been skipped here.
You don&#8217;t however need <code>applyXXXEvent</code> methods.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_frp_style">FRP Style</h3>
<div class="paragraph">
<p>Sometimes, it is not ideal to create classes to implement the queries.
Since 0.4.0, grooves has experimental support for doing this in a somewhat <em>Functional Reactive Programming</em> style.</p>
</div>
<div class="paragraph">
<p>This is an example for such a query in Kotlin.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val query =
    Grooves.versioned&lt;Account, String, Transaction, String, Balance&gt;() <i class="conum" data-value="1"></i><b>(1)</b>
        .withSnapshot { version, account -&gt;
            <i class="conum" data-value="2"></i><b>(2)</b>
            log.info("getBalance($account, $version)")
            Maybe.fromCallable { database.getBalance(account, version) }
                .map { dbBalance -&gt; Balance(dbBalance) }
                .toFlowable()
        }
        .withEmptySnapshot { Balance() } <i class="conum" data-value="3"></i><b>(3)</b>
        .withEvents { account, balance, version -&gt;
            <i class="conum" data-value="4"></i><b>(4)</b>
            val transaction =
                ContextManager.get()?.get("transaction") as Transaction?
            if (transaction != null)
                just(transaction)
            else
                empty()
        }
        .withApplyEvents { balance -&gt; true } <i class="conum" data-value="5"></i><b>(5)</b>
        .withDeprecator { balance, deprecatingAccount -&gt; /* No op */ } <i class="conum" data-value="6"></i><b>(6)</b>
        .withExceptionHandler { exception, balance, transaction -&gt;
            <i class="conum" data-value="7"></i><b>(7)</b>
            log.warn("$exception occurred")
            just(CONTINUE)
        }
        .withEventHandler(this::updateBalance) <i class="conum" data-value="8"></i><b>(8)</b>
        .build() <i class="conum" data-value="9"></i><b>(9)</b>

private fun updateBalance(transaction: Transaction, balance: Balance) =
    when (transaction) {
        is Transaction.Deposit -&gt; {
            balance.balance += transaction.amount
            just(CONTINUE)
        }
        is Transaction.Withdraw -&gt; {
            balance.balance -= transaction.amount
            just(CONTINUE)
        }
    }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Grooves</code> is a class that allows creating FRP style queries.
You can start with <code>versioned</code> or <code>temporal</code>.
It returns a query builder.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This method helps Grooves fetch a prior snapshot from the datastore. <code>account</code> is an aggregate.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This method helps Grooves create a new snapshot when none was found by the previous method.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This method helps Grooves fetch events since the last known snapshot.
<code>account</code> is the aggregate.
<code>balance</code> is the last known snapshot.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This method is optional and by default returns true.
<code>balance</code> is the snapshot.
This allows inspecting the snapshot to determine if Grooves should continue processing events.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This method allows Grooves to execute some code when a deprecation event is found.
<code>balance</code> is the snapshot
<code>deprecatingAccount</code> is the aggregate the deprecates the aggregate of <code>balance</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>This method helps Grooves decide what to do on an exception.
Returning an observable that says <code>CONTINUE</code> means processing will continue.
Returning an observable that says <code>RETURN</code> means processing will stop and the value will be returned.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>This allows Grooves to apply events on a snapshot as shown in the function <code>updateBalance</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>This returns an instance of <code>VersionedQuery</code>.
That can be used to compute snapshots.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The full source for <em>Push Style</em> Event Sourcing with <em>jOOQ</em> and FRP, look at <a href="https://github.com/rahulsom/grooves/tree/master/examples/pushstyle">this subproject</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_your_own_diagrams">Creating your own diagrams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a gradle project, if you&#8217;re using asciidoctor for documentation, you can generate diagrams using <code>grooves-diagrams</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.asciidoctor:asciidoctor-gradle-plugin:1.5.3' <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

apply plugin: 'org.asciidoctor.convert' <i class="conum" data-value="2"></i><b>(2)</b>

repositories {
    jcenter()
}

dependencies {
    asciidoctor 'com.github.rahulsom:grooves-diagrams:0.5.0-SNAPSHOT' <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This adds the asciidoctor gradle plugin to your build</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This applies the plugin</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This includes the dependency on grooves-diagrams</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now in your asciidoctor files, you can do this</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-asciidoctor" data-lang="asciidoctor">[esdiag,SimpleEvents]
....
|Type,ID,Description
  + 1 2016-01-02 created as John Lennon
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 4 2016-01-05 paid $ 100.25
....</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is this</p>
</div>
<div class="imageblock">
<div class="content">
<img src="SimpleEvents.svg" alt="SimpleEvents">
</div>
</div>
<div class="paragraph">
<p>Take a look at <a href="https://github.com/rahulsom/grooves/tree/master/grooves-docs/src/docs/asciidoc">the source</a> for more examples of creating diagrams.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_support">Support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you&#8217;re having trouble using this, head over to <a href="https://github.com/rahulsom/grooves/issues">Github Issues</a> and raise a question.
Our aim is to document things here rather than answering individual questions on the issue tracker.</p>
</div>
<div class="paragraph">
<p>If you run into a bug, feel free to create a Pull Request complete with tests, or open an issue with a detailed test description.
If you feel that the design can be enhanced, please open a ticket and start a discussion before spending time on that.</p>
</div>
</div>
</div>
</div>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.3/prism.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.9.0/plugins/keep-markup/prism-keep-markup.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.3/components/prism-clike.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.3/components/prism-java.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.3/components/prism-groovy.min.js"></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.8.3/components/prism-kotlin.min.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.0/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>