= Grooves
Rahul Somasunderam <rahul.som@gmail.com>
:stem:
:toc: left
:sectnums:

Event Sourcing for Groovy

== Introduction

Event Sourcing is a way of storing data for flexible retrieval.
The principle behind Event Sourcing is very simple.
Event Sourcing works particularly well with CQRS - Command Query Responsibility Segregation.

There are a couple of types of objects that are relevant to Event Sourcing and CQRS

Aggregate::
An aggregate is a type of object that you are interested in managing data about.
A classic example would be a bank account.

Event::
An event is an atomic change that needs to occur on the aggregate.
A suitable example for the bank account would be a transaction.
It could be an ATM withdrawal, or a check deposit, or an electronic payment.
Most events can be applied while only looking ahead.
When there is a `revert` event or a `merge` (which is represented as a `deprecates` and a `deprecatedBy` events), that doesn't hold true.

We will not be modifying the aggregate in our data store.
We will however, store the event in the data store so we know when we read to read it a certain way.


Snapshot::
A snapshot is a way of looking at the state of an aggregate at a point in time.
In our banking example, this could be your account balance.

Command::
A command is an input which causes an event to be stored.

Query::
A query is a computation that needs to be performed in order to obtain a snapshot from the events.

This is how we'll be representing events in the documentation.

[esdiag]
....
|Type,ID,Description
  + 1 2016-01-02 created as John Lennon
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 4 2016-01-05 paid $ 100.25
....

The aggregate is represented by the rectangle.
It says its type and its id in the box.
Above the box is a description of the aggregate.

The circles with numbers represent events that are applied on the aggregate.
They are reasonably spaced apart to show the flow of time.
The spacing is not necessarily linear.
However when there are multiple aggregates shown together, the time lines will be in sync.

[esdiag]
....
|Patient,1,John Lennon
  + 1 2016-01-02 created as John Lennon
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 4 2016-01-08 paid $ 100.25
  + 5 2016-01-19 paid $ 100.25
|Patient,1,Ringo Starr
  + 1 2016-01-10 created as Ringo Starr
  + 2 2016-01-11 performed FLUSHOT for $ 32.40
  + 3 2016-01-12 performed GLUCOSETEST for $ 78.93
  + 4 2016-01-19 paid $ 100.25
....

When the time of two events is exactly the same, then they are displayed like this.

[esdiag]
....
|Patient,1,John Lennon
  + 1 2016-01-02 created as John Lennon
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 4 2016-01-04 performed ANNUALPHYSICAL for $ 140.23
  + 5 2016-01-05 paid $ 100.25
....

A query performs a computation like the one below.

[stem]
++++
S_N = f(S_0, [E_1 .. E_(N)])
++++

Where

* stem:[S_N] is the Snapshot computed by applying the first `N` events.
* stem:[S_0] is the empty snapshot.

Most of the time this also holds true

[stem]
++++
S_N = f(S_k, [E_(k+1) .. E_(N)])
++++

The second one holds true only for forward events.

== Hurdles

While the theory is very simple, in practice, it's a little more complicated.
The functions that you see above are very simple at first glance, but implementing an entire system based on it requires some patterns.
That is the problem that Grooves aims to solve.

=== Completeness of Queries

When applying events on a Snapshot, you need to be sure that you have handled every single event type.
Let's say you've got 3 types of events for an aggregate and 2 snapshots.
If you add a new event type, you need to handle it in the computation of both snapshots.
When a language has case classes, it's easier to achieve this.
Alas, Groovy and Java do not have case classes.

There are some special kinds of Events that require a lot of complex handling:

=== Reverting Events

Some times events are entered into an aggregate's timeline in error.
This could be a system error, or a human error.
When this happens, for the business logic to make sense, the system should behave as if that event never occurred.
However, for auditing purposes, and for preserving a reasonable system, the original event as well as the moment the error was detected need to be tracked.

[esdiag]
....
|Patient,1,Paul McCartney
  + 1 2016-01-02 created as Paul McCartney
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  - 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 4 2016-01-05 paid $ 100.25
  + 5 2016-01-15 reverted 3
....

In the diagram above, we see that event 3 was performed, and later after event 4, we realized that 3 should not have occurred.
Now, we insert a special event, 5, that causes a revert of 3.
Once the system processes the data correctly, this is equivalent to what follows.

[esdiag]
....
|Patient,1,Paul McCartney
  + 1 2016-01-02 created as Paul McCartney
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 4 2016-01-05 paid $ 100.25
  + 5 2016-01-15 .
....

Depending on how many mistakes people and systems make, this could be much more complicated.
For example, you might be able to revert a revert event.

[esdiag]
....
|Patient,1,Paul McCartney
  + 1 2016-01-02 created as Paul McCartney
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 4 2016-01-05 paid $ 100.25
  - 5 2016-01-15 reverted 3
  + 6 2016-01-16 reverted 5
....

This should be interpreted as 6 cancels out 5, so 5 can no more cancel out 3.

[esdiag]
....
|Patient,1,Paul McCartney
  + 1 2016-01-02 created as Paul McCartney
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 4 2016-01-05 paid $ 100.25
  + 5 2016-01-15 .
  + 6 2016-01-16 .
....

=== Merging Aggregates

`DeprecatedBy` and `Deprecates` is a pair of events that work together on aggregates of the same type.
Sometimes, real world things merge together.
For example, companies get merged or acquired.
Sometimes, you accidentally create two aggregates that represent the same thing.

[esdiag]
....
|Patient,4,Farrokh Bulsara
  + 1 2016-01-02 created as Farrokh Bulsara
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 7 2016-01-09 deprecates 5 converse 6
  + 8 2016-01-11 performed ANNUALPHYSICAL for $ 78.93
|Patient,5,Freddie Mercury
  + 4 2016-01-05 created as Freddie Mercury
  + 5 2016-01-05 paid $ 100.25
  + 6 2016-01-09 deprecated by 4 converse 7
....

In this case, we created two patients that actually represent the same person.
Then we realized that this needs to be the same person.
While reading this, we would treat it as if it was like this.

[esdiag]
....
|Patient,4,Farrokh Bulsara
  + 1 2016-01-02 created as Farrokh Bulsara
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 5 2016-01-05 paid $ 100.25
  + 6 2016-01-09 deprecated by 4 converse 7
  + 7 2016-01-09 deprecates 5 converse 6
  + 8 2016-01-11 performed ANNUALPHYSICAL for $ 78.93
....

Typically we cannot apply any new events after 6 on Aggregate 5.
The exception to the rule is when we're reverting the merge.
That might not always be true.
Some systems might choose to continue adding events on an aggregate like 5.

=== Reverting Merges

Lets assume we got confused with a pair of aggregates like these and performed a merge like this.

[esdiag]
....
|Patient,4,Tina Fey
  + 1 2016-01-02 created as Tina Fey
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 7 2016-01-09 deprecates 5 converse 6
  + 8 2016-01-11 performed ANNUALPHYSICAL for $ 78.93
|Patient,5,Sarah Palin
  + 4 2016-01-05 created as Sarah Palin
  + 5 2016-01-05 paid $ 100.25
  + 6 2016-01-09 deprecated by 4 converse 7
....

The correct way of reverting fixing this mistake, would be to perform a pair of reverts.
This is complicated, but necessary in order to make the reads on both aggregates result in the merge being ignored.

[esdiag]
....
|Patient,4,Tina Fey
  + 1 2016-01-02 created as Tina Fey
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  - 7 2016-01-09 deprecates 5 converse 6
  + 8 2016-01-11 performed ANNUALPHYSICAL for $ 78.93
  + 9 2016-01-12 reverted 7
|Patient,5,Sarah Palin
  + 4 2016-01-05 created as Sarah Palin
  + 5 2016-01-05 paid $ 100.25
  - 6 2016-01-09 deprecated by 4 converse 7
  + 10 2016-01-12 reverted 6
....

=== Performing joins

In an event sourced system, even joins are just events.
That way we can preserve their temporal changes.

[esdiag]
....
|Department,1,Engineering
  + 1 2016-01-02 created as Farrokh Bulsara
  + 2 2016-01-03 performed FLUSHOT for $ 32.40
  + 3 2016-01-04 performed GLUCOSETEST for $ 78.93
  + 7 2016-01-05 joins 5 converse 5
  + 8 2016-01-11 performed ANNUALPHYSICAL for $ 78.93
|Employee,5,Scotty
  + 4 2016-01-05 created as Scotty
  + 5 2016-01-05 joins 1 converse 7
....

=== Performing disjoins

Since joins can change with time, you could have a situation where you need to perform a `disjoin`.
In our example here, Mr Spock stops being the Science Officer when he becomes captain.
For that to happen, we need to represent that the relationship between the department Science and Mr Spock is severed at a point in time.

[esdiag]
....
|Department,1,Science
  + 1 2016-01-02 created as Science
  + 1a 2016-01-03 .
  + 5 2016-01-05 joins 5 converse 4
  + 7 2016-01-10 disjoins 5 converse 6
|Department,2,Command
  + 2 2016-01-02 created as Command
  + 9 2016-01-10 joins 5 converse 8
|Employee,5,Mr Spock
  + 3 2016-01-05 created as Mr Spock
  + 4 2016-01-05 joins by 1 converse 5
  + 6 2016-01-10 disjoins by 1 converse 7
  + 8 2016-01-10 joins by 2 converse 9
....

You might be tempted to reuse the revert capability here.
A disjoin is different from a revert.
The difference between a disjoin and a revert is the same as the difference between a divorce and an annulment.

== How Grooves solves it

Grooves assumes nothing about your persistence framework or whether you're building a webapp or a batch application.
Grooves only offers three things

* Interfaces for the Aggregate, Event (and its subtypes) and Snapshot.
* Annotations to mark these and AST Transformations to ensure all event types are covered in a Query implementation.
* A Trait that helps write queries to compute snapshots.

This allows you to use Grooves with a lot of different frameworks.
There are examples in the repository for some options you could use.

== Building an Event Sourcing System with Grooves

???